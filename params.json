{"name":"Node-girror","body":"# girror - Efficient mirroring of git remotes #\r\n\r\n[![Build Status](https://secure.travis-ci.org/eladb/node-girror.png?branch=master)](http://travis-ci.org/eladb/node-girror)\r\n\r\n_girror_ maintains mirrors of git repositories on the local system using a bare repository cache.\r\nThis makes it especially useful to handle post-commit triggers and automatically pull changes from a remote.\r\n\r\n```bash\r\n$ sudo npm install -g girror\r\n$ girror git@github.com/eladb/node-girror /tmp/node-girror-master\r\n$ girror git@github.com/eladb/node-girror#branch1 /tmp/node-girror-branch1\r\n```\r\n\r\nNow, every time the remote changes, calling _girror_ again will update the worktree.\r\n\r\n_girror_ uses a bare repository with a `--mirror=fetch` origin to maintain a cached mirror of the remote.\r\n\r\nIt essentially performs the following steps:\r\n\r\n```\r\ngit init --bare # idempotent\r\ngit remote add --mirror=fetch <remote> # tolerate failures\r\ngit fetch origin\r\ngit --work-tree <worktree> checkout -f <branch>\r\n```\r\n\r\nThe bare repository will be created in a directory under `/tmp/girror-cache` (or `$TEMP/girror-cache` in Windows).\r\nThe name of the directory is based on the remote URL (mangled).\r\nIf `GIRROR_CACHE` environment variable is defined, it will be used as the cache root.\r\n\r\n_girror_ can be used as a command line tool or as a node.js in-process module.\r\n\r\nSince git supports concurrency both for `fetch` and `checkout`, girror is also safe. Multiple girror operations may run in parallel.\r\nHowever, this might not be very efficient since the initial fetch operation may take a long time and running multiple fetch operations against the same repository\r\nwill be wasty. If you have multiple girror operations that you wish to run against the same repository (e.g. checkout different branches/tags to various working\r\ntrees), you might want to do a single girror operation first that will perform the initial fetch and then run all the rest concurrently.\r\n\r\n## Command line ##\r\n\r\n```bash\r\n$ girror --help\r\n\r\n  Usage: girror                             - resync current directory (read <remote-url> and <branch> from .girror.json)\r\n         girror work-tree                   - resync <worktree> (read <remote-url> and <branch> from .girror.json)\r\n         girror remote-url worktree         - sync/resync <remote-url> into <worktree> and checkout \"master\"\r\n         girror remote-url#branch worktree  - sync/resync <remote-url> into <worktree> and checkout <branch>\r\n\r\n  Options:\r\n\r\n    -h, --help             output usage information\r\n    -v, --verbose          verbose output\r\n    --shallow              create a shallow clone (--depth=1)\r\n    --no-girror-file       do not create .girror.json file in worktree\r\n    --find-remote          output the remote URL of the specified <worktree>, if a girror file can be found\r\n\r\n```\r\n\r\n## API ##\r\n\r\n### girror(remote, worktree, options, callback) ###\r\n\r\n * `remote` - the URL of the git remote (postfix with '#branch' to checkout a specific branch). \r\n    If `remote` is `null`, `girror` will look for a `.girror.json` file up the file system and will induce remote#branch from there.\r\n * `worktree` - path to local working directory (where you want files to be checked out into)\r\n * `options.cachedir` - where to store the bare repo cache that makes girror so awesome (default is $GIRROR_CACHE || ($TMP || $TEMP || /tmp)/girror-cache)\r\n * `options.logger` - optional alternative to `console`.\r\n * `options.remote_type` - A mapper for the remote URL (`function(remote_url) => remote_url`).\r\n   You can either provide your own function, or use one of the built in ones:\r\n   * `girror.remote_types.no_auth()` - passthru (the default)\r\n   * `girror.remote_types.auth(user, password)` - add `user:password@` to URL.\r\n   * `girror.remote_types.github_ssh()` - convert a github (e.g. https://github.com/account/repo) URL to an \r\n     SSH URL (e.g. `git@github.com/account/repo.git`)\r\n * `options.girrorfile` - The name of the girror file to create under the worktree (contains some metadata on the last girror operation). Set to `false` to disable. Default is `.girror.json`.\r\n * `options.depth`: defines the clone depth (-1 indicates infinite). Default is -1.\r\n\r\n### girror.git(args, options, callback) ###\r\n\r\nInvokes `git`. Returns a `ChildProcess` object that can be used to grab stdio or whatever.\r\n\r\n * `args` array of arguments to pass to `git`.\r\n * `options.env` environment hash (default is `process.env`)\r\n * `options.logger` optional logger (default is `console`)\r\n * `options.tolerate` never fail (default `false`)\r\n * `options.verbose` verbose output (default `true`)\r\n * `callback` is `function(err)`\r\n\r\n### girror.find_meta(dir, options, callback) ###\r\n\r\nThis function will look for a girror file under `dir` and any of it's parents. It will parse the first one it finds and return it via the callback function (`function(err, meta)`). If the girror file could not be found, `meta` will be `null`.\r\n`options.girrorfile` may contain a different name for the girror file and `options` is optional.\r\n\r\n## Using girror for continuous deployment ##\r\n\r\ngirror was built to enable automatic deployment from source control:\r\n\r\n 1. Set up a post-commit HTTP trigger on your favorite source control that will POST into some endpoint on your servers.\r\n 2. Invoke _girror_ to sync from the remote repository into the local filesystem. _girror_ will do it as efficiently and painlessly as possible (no merges, no cleanups, only clean diffs).\r\n 3. You can also use it to sync multiple branches into your production servers and use them as staging environments (yeah!).\r\n\r\nI will create a \"girror-middleware\" for express so you can just plug it in and have all this automated.\r\n\r\n## Credits ##\r\n\r\n * [@mojodna](https://github.com/mojodna)\r\n\r\n## License ##\r\n\r\nMIT\r\n","tagline":"Efficient mirroring of git remotes","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}